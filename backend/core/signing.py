"""
Cryptographic Signing Module
============================

Provides ECDSA P-256 signing and verification for chain-of-custody entries.
Ensures tamper-evident audit trail for all forensic operations.
"""

import hashlib
import json
from dataclasses import dataclass, field
from datetime import datetime, timezone
from typing import Any, Optional
from uuid import UUID

from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.backends import default_backend
from cryptography.exceptions import InvalidSignature

from core.logging import get_logger

logger = get_logger(__name__)


@dataclass
class SignedEntry:
    """
    A signed content entry for chain-of-custody.
    
    Attributes:
        content: The original content dict
        content_hash: SHA-256 hash of JSON-serialized content
        signature: ECDSA signature of (content_hash + timestamp_utc)
        agent_id: Identifier of the agent that signed
        timestamp_utc: UTC timestamp when signed
    """
    content: dict[str, Any]
    content_hash: str
    signature: str
    agent_id: str
    timestamp_utc: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    
    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "content": self.content,
            "content_hash": self.content_hash,
            "signature": self.signature,
            "agent_id": self.agent_id,
            "timestamp_utc": self.timestamp_utc.isoformat(),
        }
    
    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> "SignedEntry":
        """Create from dictionary."""
        return cls(
            content=data["content"],
            content_hash=data["content_hash"],
            signature=data["signature"],
            agent_id=data["agent_id"],
            timestamp_utc=datetime.fromisoformat(data["timestamp_utc"])
            if isinstance(data["timestamp_utc"], str)
            else data["timestamp_utc"],
        )


@dataclass
class AgentKeyPair:
    """
    ECDSA P-256 key pair for an agent.
    
    Attributes:
        agent_id: Unique identifier for the agent
        private_key: ECDSA private key
        public_key: ECDSA public key
    """
    agent_id: str
    private_key: ec.EllipticCurvePrivateKey
    public_key: ec.EllipticCurvePublicKey
    
    @classmethod
    def generate(cls, agent_id: str) -> "AgentKeyPair":
        """Generate a new ECDSA P-256 key pair for an agent."""
        private_key = ec.generate_private_key(ec.SECP256R1(), default_backend())
        return cls(
            agent_id=agent_id,
            private_key=private_key,
            public_key=private_key.public_key(),
        )
    
    def get_public_key_pem(self) -> str:
        """Get public key in PEM format for storage/transmission."""
        pem = self.public_key.public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo,
        )
        return pem.decode("utf-8")


class KeyStore:
    """
    In-memory store for agent key pairs.
    
    In production, this would be backed by an HSM or secure key management service.
    For development and testing, keys are stored in memory.
    """
    
    def __init__(self) -> None:
        """Initialize the key store."""
        self._keys: dict[str, AgentKeyPair] = {}
    
    def get_or_create(self, agent_id: str) -> AgentKeyPair:
        """
        Get existing key pair for agent, or create new one.
        
        Args:
            agent_id: Unique identifier for the agent
        
        Returns:
            AgentKeyPair for the agent
        """
        if agent_id not in self._keys:
            self._keys[agent_id] = AgentKeyPair.generate(agent_id)
            logger.info("Generated new key pair for agent", agent_id=agent_id)
        return self._keys[agent_id]
    
    def get(self, agent_id: str) -> Optional[AgentKeyPair]:
        """
        Get existing key pair for agent without creating.
        
        Args:
            agent_id: Unique identifier for the agent
        
        Returns:
            AgentKeyPair if exists, None otherwise
        """
        return self._keys.get(agent_id)
    
    def clear(self) -> None:
        """Clear all stored keys (for testing)."""
        self._keys.clear()


# Global keystore instance
_keystore: Optional[KeyStore] = None


def get_keystore() -> KeyStore:
    """Get or create the global keystore instance."""
    global _keystore
    if _keystore is None:
        _keystore = KeyStore()
    return _keystore


def compute_content_hash(content: dict[str, Any]) -> str:
    """
    Compute SHA-256 hash of JSON-serialized content.
    
    Args:
        content: Dictionary to hash
    
    Returns:
        Hex-encoded SHA-256 hash
    """
    # Sort keys for deterministic serialization
    content_json = json.dumps(content, sort_keys=True, separators=(",", ":"))
    return hashlib.sha256(content_json.encode("utf-8")).hexdigest()


def sign_content(
    agent_id: str,
    content: dict[str, Any],
    keystore: Optional[KeyStore] = None,
    timestamp: Optional[datetime] = None,
) -> SignedEntry:
    """
    Sign content with agent's private key.
    
    Computes SHA-256 hash of content, then signs (hash + timestamp) with
    the agent's ECDSA private key.
    
    Args:
        agent_id: Identifier of the signing agent
        content: Content dictionary to sign
        keystore: Optional keystore (uses global if not provided)
        timestamp: Optional timestamp (uses current UTC if not provided)
    
    Returns:
        SignedEntry with content, hash, signature, and metadata
    """
    if keystore is None:
        keystore = get_keystore()
    
    key_pair = keystore.get_or_create(agent_id)
    
    # Compute content hash
    content_hash = compute_content_hash(content)
    
    # Use provided timestamp or current UTC
    if timestamp is None:
        timestamp = datetime.now(timezone.utc)
    
    # Create message to sign: content_hash + timestamp_iso
    timestamp_iso = timestamp.isoformat()
    message = f"{content_hash}:{timestamp_iso}".encode("utf-8")
    
    # Sign with ECDSA
    signature = key_pair.private_key.sign(
        message,
        ec.ECDSA(hashes.SHA256()),
    )
    
    # Encode signature as hex for storage
    signature_hex = signature.hex()
    
    logger.debug(
        "Signed content",
        agent_id=agent_id,
        content_hash=content_hash[:16] + "...",
    )
    
    return SignedEntry(
        content=content,
        content_hash=content_hash,
        signature=signature_hex,
        agent_id=agent_id,
        timestamp_utc=timestamp,
    )


def verify_entry(
    entry: SignedEntry,
    keystore: Optional[KeyStore] = None,
) -> bool:
    """
    Verify a signed entry's signature.
    
    Recomputes content hash and verifies the signature using the agent's
    public key. Returns False on any verification failure (never raises).
    
    Args:
        entry: SignedEntry to verify
        keystore: Optional keystore (uses global if not provided)
    
    Returns:
        True if signature is valid, False otherwise
    """
    try:
        if keystore is None:
            keystore = get_keystore()
        
        # Get the agent's key pair
        key_pair = keystore.get(entry.agent_id)
        if key_pair is None:
            logger.warning(
                "Verification failed: no key for agent",
                agent_id=entry.agent_id,
            )
            return False
        
        # Recompute content hash
        expected_hash = compute_content_hash(entry.content)
        if expected_hash != entry.content_hash:
            logger.warning(
                "Verification failed: content hash mismatch",
                expected=expected_hash[:16] + "...",
                actual=entry.content_hash[:16] + "...",
            )
            return False
        
        # Reconstruct message
        timestamp_iso = entry.timestamp_utc.isoformat()
        message = f"{entry.content_hash}:{timestamp_iso}".encode("utf-8")
        
        # Decode signature from hex
        signature_bytes = bytes.fromhex(entry.signature)
        
        # Verify signature
        key_pair.public_key.verify(
            signature_bytes,
            message,
            ec.ECDSA(hashes.SHA256()),
        )
        
        logger.debug(
            "Verified entry signature",
            agent_id=entry.agent_id,
            content_hash=entry.content_hash[:16] + "...",
        )
        return True
        
    except InvalidSignature:
        logger.warning(
            "Verification failed: invalid signature",
            agent_id=entry.agent_id,
        )
        return False
    except Exception as e:
        logger.warning(
            "Verification failed with exception",
            agent_id=entry.agent_id,
            error=str(e),
        )
        return False
